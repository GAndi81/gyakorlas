<!DOCTYPE html>
<html lang="hu">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Javascript design patterns</title>
</head>

<body>

    <script>
        //JAVASCRIPT MODULE PATTERNS:

        // 1. CONSTRUCTOR PATTERN in Javascript (this is a creational pattern)


        //object constructor is used to created a specific types of object -
        //preparing the object for use and accepting arguments
        // többféle módon hozhatunk létre objecteket,  pl. object define property-vel 

        //constructor függvény létrehozása -
        //a  this kulcsszó mutat az új megalkotott objectre


        // ELső példa - új személy létrehozása CONSTRUCTOR PROTOTYPE-AL:
        function Person(firstName, lastName) {

            this.firstName = firstName;
            this.lastName = lastName;
        }

        Person.prototype.sayName = function () {
            return 'My name is' + this.firstName + '' + this.lastName;
        };

        var johnDoe = new Person('John', 'Doe');
        var janeDoe = new Person('Jane', 'Doe');

        var isPerson = johnDoe instanceof Person; //true
        var isSame = johnDoe.sayName === janeDoe.sayName; //false

        // Második példa - példa autókkal a CONTSTRUCTOR FÜGGVÉNYRE:

        function Car(model, year, miles) {

            this.model = model;
            this.year = year;
            this.miles = miles;

            this.toString = function () {
                return this.model + " has done " + this.miles + " miles";
            };
        }

        // We can create new instances of the car
        var civic = new Car("Honda Civic", 2009, 20000);
        var mondeo = new Car("Ford Mondeo", 2010, 5000);

        // and then open our browser console to view the
        // output of the toString() method being called on
        // these objects
        console.log(civic.toString());
        console.log(mondeo.toString());

        // Mi a gond a fentiekkel?
        // az öröklődést bonyolulttá teszi
        //a toString() metódust minden egyes új autó létrehozásánál újra kell definiálni

        // ELŐZŐ PÉLDA MEGOLDÁSA CONTRUCTOR PROTOTYPE_AL

        function Car(model, year, miles) {

            this.model = model;
            this.year = year;
            this.miles = miles;

        }

        // Note here that we are using Object.prototype.newMethod rather than
        // Object.prototype so as to avoid redefining the prototype object
        Car.prototype.toString = function () {
            return this.model + " has done " + this.miles + " miles";
        };

        // Usage:

        var civic = new Car("Honda Civic", 2009, 20000);
        var mondeo = new Car("Ford Mondeo", 2010, 5000);

        console.log(civic.toString());
        console.log(mondeo.toString());
        //a toString() metódust mindegyik CAR objecten használható


        // A MODULE PATTERN:

        //MODULES: integral piece of any robust application's architecture and help in keeeping the code cleanly separated and organized
        // Mire használjuk Javascriptben? - EMuláció - másolás, utánzás, a szimulációhoz hasonlatos, egy adott működési környezetet más körülmények
        // között utánzó technológia - PRIVACY!!! arra, hogy privát és publikus metódusokat/változókat hozhassunk létre és használhassunk
        // az egyik leginkább akalmazott pattern, célja, hogy az egye kódrészleteket egymástól függetlenül tartsa
        // enkapszuláció - 
        // van ES6 előtti és ES6 utáni verziója
        // a pattern tartalmaz egy IIFE-t vagyis immediately invoked function expressiont
        //Within the Module pattern, 
        //variables or methods declared are only available inside the module itself thanks to closure.
        //Variables or methods defined within the returning object however are available to everyone.

        // ELSŐ PÉLDA - self-contained module:

        var testModule = (function () {

            var counter = 0;

            return {

                incrementCounter: function () {
                    return counter++;
                },

                resetCounter: function () {
                    console.log("counter value prior to reset: " + counter);
                    counter = 0;
                }
            };

        })();

        // Usage:

        // Increment our counter
        testModule.incrementCounter();

        // Check the counter value and reset
        // Outputs: counter value prior to reset: 1
        testModule.resetCounter();

        // MÁSODIK PÉLDA a private/publikus változókra és elnevezésekre:

        var myNamespace = (function () {

            var myPrivateVar, myPrivateMethod;

            // A private counter variable
            myPrivateVar = 0;

            // A private function which logs any arguments
            myPrivateMethod = function (foo) {
                console.log(foo);
            };

            return {

                // A public variable
                myPublicVar: "foo",

                // A public function utilizing privates
                myPublicFunction: function (bar) {

                    // Increment our private counter
                    myPrivateVar++;

                    // Call our private method using bar
                    myPrivateMethod(bar);

                }
            };

        })();


        var myNamespace = (function () {

            var myPrivateVar, myPrivateMethod;

            // A private counter variable
            myPrivateVar = 0;

            // A private function which logs any arguments
            myPrivateMethod = function (foo) {
                console.log(foo);
            };

            return {

                // A public variable
                myPublicVar: "foo",

                // A public function utilizing privates
                myPublicFunction: function (bar) {

                    // Increment our private counter
                    myPrivateVar++;

                    // Call our private method using bar
                    myPrivateMethod(bar);

                }
            };

        })();


        // HARMADIK PÉLDA - BUSKET MODULE: 

        var basketModule = (function () {

            // privates

            var basket = [];

            function doSomethingPrivate() {
                //...
            }

            function doSomethingElsePrivate() {
                //...
            }

            // Return an object exposed to the public
            return {

                // Add items to our basket
                addItem: function (values) {
                    basket.push(values);
                },

                // Get the count of items in the basket
                getItemCount: function () {
                    return basket.length;
                },

                // Public alias to a private function
                doSomething: doSomethingPrivate,

                // Get the total value of items in the basket
                getTotal: function () {

                    var q = this.getItemCount(),
                        p = 0;

                    while (q--) {
                        p += basket[q].price;
                    }

                    return p;
                }
            };
        })();

        //PÉLDA - A BASKETMODULHOZ TARTOZÓ RÉSZ:
        // basketModule returns an object with a public API we can use

        basketModule.addItem({
            item: "bread",
            price: 0.5
        });

        basketModule.addItem({
            item: "butter",
            price: 0.3
        });

        // Outputs: 2
        console.log(basketModule.getItemCount());

        // Outputs: 0.8
        console.log(basketModule.getTotal());

        // However, the following will not work:

        // Outputs: undefined
        // This is because the basket itself is not exposed as a part of our
        // public API
        console.log(basketModule.basket);

        // This also won't work as it only exists within the scope of our
        // basketModule closure, but not in the returned public object
        console.log(basket);

        //ELŐNYÖK: private functions and objects létrehozása, object-oriented körnfryezetből érkezőkek sokka tisztábbnak tűnik elsőre
        // supports private data - vagyis a public parts of our codes are able to touch private data, but from outside the private data is untouchable.


        //HÁTRÁNYOK:
        //ha pl rálátást szeretnénk módosítani, akkor mindenütt külön meg kell tennünk a vátoztatást
        //nem lehet létrehozni vele automatikusan unit teszteket a private membereknek - a privát adatot nem lehet patchelni

        //MODULE PATTERN VARIATIONS:
        //a. Import mixins
        //b. Exports
        //c. Dojo
        //d.ExtJS
        //e.YUI
        //f.jQuery

        //A REVEALING MODULE PATTERN:


        // a module pattern kissé fejlett változata ami: létrehozzuk a functionst és változókat mind private scope-al
        // és egy anonymous object returns with pointers to the private functionality we wished to reveal as public

        // ELSŐ PÉLDA a REVEALING MODULE-re
        var myRevealingModule = (function () {

            var privateVar = "Ben Cherry",
                publicVar = "Hey there!";

            function privateFunction() {
                console.log("Name:" + privateVar);
            }

            function publicSetName(strName) {
                privateVar = strName;
            }

            function publicGetName() {
                privateFunction();
            }


            // Reveal public pointers to
            // private functions and properties

            return {
                setName: publicSetName,
                greeting: publicVar,
                getName: publicGetName
            };

        })();

        myRevealingModule.setName("Paul Kinlan");

        //MÁSODIK PÉLDA A REVEALING MODULE-RE:

        var module1 = (function () {
            //private zone:
            console.log('hello world');

            var doSomething = function () {
                console.log('doing something');
            }

            return publicDoSomething: doSomething;
        })();

        module1.publicDoSomething();


        //ELŐNYEI: átláthatóbb és konzisztensebb a kód
        //HÁTRÁNYAI: ha egy private function egy publicra mutat, akkor nem lehet felülírni
        // kissé törékenyebb ezért a module patternnél
    </script>
</body>

</html>